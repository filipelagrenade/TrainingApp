/// LiftIQ - Weight Recommendation Model
///
/// Represents weight and rep recommendations for progressive overload.
/// Uses a rule-based double progression algorithm by default, with optional
/// AI enhancement when the Groq API is configured.
///
/// These models are used by the recommendation service to suggest optimal
/// weights and reps based on the user's training history and preferences.
///
/// ## Architecture
/// ```
/// WorkoutRecommendations
///   └── List<ExerciseRecommendation>
///         └── List<SetRecommendation>
/// ```
///
/// ## Usage
/// ```dart
/// final recommendations = await recommendationService.generateRecommendations(
///   templateId: 'push-day',
///   exercises: exercises,
///   preferences: trainingPreferences,
/// );
///
/// // Access recommendations for a specific exercise
/// final benchRec = recommendations.getForExercise('bench-press');
/// print('Suggested: ${benchRec.sets.first.weight}kg x ${benchRec.sets.first.reps}');
/// ```
library;

import 'package:freezed_annotation/freezed_annotation.dart';

part 'weight_recommendation.freezed.dart';
part 'weight_recommendation.g.dart';

// ============================================================================
// ENUMS
// ============================================================================

/// Confidence level of a recommendation.
///
/// Higher confidence means more historical data was available
/// and the recommendation is more reliable.
enum RecommendationConfidence {
  /// High confidence - 4+ previous sessions with consistent data
  high,

  /// Medium confidence - 2-3 previous sessions
  medium,

  /// Low confidence - 0-1 previous sessions, using estimates
  low,
}

/// Source of the recommendation.
///
/// Indicates how the recommendation was generated.
enum RecommendationSource {
  /// Generated by the AI (Groq API)
  ai,

  /// Generated by the local algorithm (offline fallback)
  algorithm,

  /// Using template default values (no history available)
  templateDefault,
}

// ============================================================================
// SET RECOMMENDATION
// ============================================================================

/// Recommendation for a single set.
///
/// Contains the suggested weight, reps, and optional target RPE.
@freezed
class SetRecommendation with _$SetRecommendation {
  const factory SetRecommendation({
    /// Set number (1-indexed)
    required int setNumber,

    /// Recommended weight in user's preferred unit
    required double weight,

    /// Recommended number of reps
    required int reps,

    /// Target RPE for this set (optional)
    double? targetRpe,
  }) = _SetRecommendation;

  factory SetRecommendation.fromJson(Map<String, dynamic> json) =>
      _$SetRecommendationFromJson(json);
}

/// Extension methods for SetRecommendation.
extension SetRecommendationExtensions on SetRecommendation {
  /// Returns a formatted display string.
  ///
  /// Example: "82.5 kg x 8" or "82.5 kg x 8 @ RPE 8"
  String toDisplayString({String unit = 'kg', bool showRpe = false}) {
    final weightStr = weight % 1 == 0 ? weight.toInt().toString() : weight.toString();
    final base = '$weightStr $unit x $reps';
    if (showRpe && targetRpe != null) {
      return '$base @ RPE ${targetRpe!.toStringAsFixed(0)}';
    }
    return base;
  }

  /// Returns a short display string for chips.
  ///
  /// Example: "82.5 x 8"
  String toShortString() {
    final weightStr = weight % 1 == 0 ? weight.toInt().toString() : weight.toString();
    return '$weightStr x $reps';
  }
}

// ============================================================================
// EXERCISE RECOMMENDATION
// ============================================================================

/// Recommendation for a complete exercise.
///
/// Contains set recommendations and metadata about the suggestion.
@freezed
class ExerciseRecommendation with _$ExerciseRecommendation {
  const factory ExerciseRecommendation({
    /// Exercise ID for lookup
    required String exerciseId,

    /// Exercise name for display
    required String exerciseName,

    /// List of set recommendations
    required List<SetRecommendation> sets,

    /// Confidence level of this recommendation
    required RecommendationConfidence confidence,

    /// How this recommendation was generated
    required RecommendationSource source,

    /// Human-readable reasoning for the recommendation
    String? reasoning,

    /// Whether this represents a progression from the last session
    @Default(false) bool isProgression,

    /// The weight increase from last session (if progression)
    double? weightIncrease,

    /// Previous best weight for comparison
    double? previousWeight,

    /// Previous best reps for comparison
    int? previousReps,

    /// Phase-specific feedback message for the user.
    /// Shows contextual information like "3 more reps to hit ceiling"
    /// or "Weight increased - aim for 8+ reps".
    String? phaseFeedback,
  }) = _ExerciseRecommendation;

  factory ExerciseRecommendation.fromJson(Map<String, dynamic> json) =>
      _$ExerciseRecommendationFromJson(json);
}

/// Extension methods for ExerciseRecommendation.
extension ExerciseRecommendationExtensions on ExerciseRecommendation {
  /// Returns the first set's recommendation (most commonly displayed).
  SetRecommendation? get firstSet => sets.isNotEmpty ? sets.first : null;

  /// Returns true if confidence is high.
  bool get isHighConfidence => confidence == RecommendationConfidence.high;

  /// Returns true if this was generated by AI.
  bool get isAiGenerated => source == RecommendationSource.ai;

  /// Returns the confidence color for UI display.
  ///
  /// High = green, Medium = amber, Low = grey
  String get confidenceColorHex => switch (confidence) {
    RecommendationConfidence.high => '#22C55E',    // Green
    RecommendationConfidence.medium => '#F59E0B',  // Amber
    RecommendationConfidence.low => '#9CA3AF',     // Grey
  };

  /// Returns a short summary string for display.
  ///
  /// Example: "↑ 82.5kg x 8 (High confidence)"
  String toSummaryString({String unit = 'kg'}) {
    if (sets.isEmpty) return 'No recommendation';
    final first = sets.first;
    final prefix = isProgression ? '↑ ' : '';
    final confidenceStr = switch (confidence) {
      RecommendationConfidence.high => 'High',
      RecommendationConfidence.medium => 'Medium',
      RecommendationConfidence.low => 'Low',
    };
    return '$prefix${first.weight} $unit x ${first.reps} ($confidenceStr)';
  }
}

// ============================================================================
// WORKOUT RECOMMENDATIONS
// ============================================================================

/// Complete set of recommendations for a workout.
///
/// Contains recommendations for all exercises in the workout template.
@freezed
class WorkoutRecommendations with _$WorkoutRecommendations {
  const factory WorkoutRecommendations({
    /// Template ID these recommendations are for
    required String templateId,

    /// Map of exercise ID to recommendation
    required Map<String, ExerciseRecommendation> exercises,

    /// When these recommendations were generated
    required DateTime generatedAt,

    /// Number of previous sessions analyzed
    required int sessionsAnalyzed,

    /// Current program week (if applicable)
    int? programWeek,

    /// Overall notes or summary from AI
    String? overallNotes,
  }) = _WorkoutRecommendations;

  factory WorkoutRecommendations.fromJson(Map<String, dynamic> json) =>
      _$WorkoutRecommendationsFromJson(json);
}

/// Extension methods for WorkoutRecommendations.
extension WorkoutRecommendationsExtensions on WorkoutRecommendations {
  /// Gets the recommendation for a specific exercise.
  ///
  /// Returns null if no recommendation exists for that exercise.
  ExerciseRecommendation? getForExercise(String exerciseId) {
    return exercises[exerciseId];
  }

  /// Returns true if recommendations exist for any exercises.
  bool get hasRecommendations => exercises.isNotEmpty;

  /// Returns the number of exercises with recommendations.
  int get recommendationCount => exercises.length;

  /// Returns the number of progressions suggested.
  int get progressionCount =>
      exercises.values.where((e) => e.isProgression).length;

  /// Returns true if these recommendations are stale (> 1 hour old).
  bool get isStale {
    final age = DateTime.now().difference(generatedAt);
    return age.inHours > 1;
  }

  /// Returns a summary of the recommendations.
  String toSummary() {
    if (!hasRecommendations) return 'No recommendations available';
    final progressions = progressionCount;
    if (progressions > 0) {
      return '$progressions exercise${progressions > 1 ? 's' : ''} ready to progress';
    }
    return 'Maintain current weights';
  }
}

// ============================================================================
// EXERCISE HISTORY DATA (for service use)
// ============================================================================

/// Historical data for an exercise used to generate recommendations.
///
/// This is an internal data structure used by the recommendation service.
@freezed
class ExerciseHistoryData with _$ExerciseHistoryData {
  const factory ExerciseHistoryData({
    /// Exercise ID
    required String exerciseId,

    /// Exercise name
    required String exerciseName,

    /// List of session data, most recent first
    required List<SessionExerciseData> sessions,
  }) = _ExerciseHistoryData;

  factory ExerciseHistoryData.fromJson(Map<String, dynamic> json) =>
      _$ExerciseHistoryDataFromJson(json);
}

/// Data for a single session of an exercise.
@freezed
class SessionExerciseData with _$SessionExerciseData {
  const factory SessionExerciseData({
    /// When this session occurred
    required DateTime date,

    /// Sets performed in this session
    required List<HistoricalSetData> sets,

    /// Whether all target reps were achieved
    @Default(false) bool allRepsAchieved,

    /// Average RPE across sets (if recorded)
    double? averageRpe,
  }) = _SessionExerciseData;

  factory SessionExerciseData.fromJson(Map<String, dynamic> json) =>
      _$SessionExerciseDataFromJson(json);
}

/// Historical set data.
@freezed
class HistoricalSetData with _$HistoricalSetData {
  const factory HistoricalSetData({
    required double weight,
    required int reps,
    double? rpe,
  }) = _HistoricalSetData;

  factory HistoricalSetData.fromJson(Map<String, dynamic> json) =>
      _$HistoricalSetDataFromJson(json);
}
